> 如果对声明了`volatile`的变量进行写操作，JVM就会向处理器发送⼀条`Lock前缀`的指令，将这个变量所在缓存行的数据写回到系统内存。

在多CPU的条件下，即使刚刚的CPU将修改后的缓存行数据写回了主存当中，但是其他的CPU保存的变量还是未经过修改的值，因此此时就需要缓存一致性协议（如MESI）来发送消息使其他保存了这个变量的CPU的缓存行失效，这样，其他CPU如果对该变量进行操作的时候，就需要重新从主存中获取。

volatile的实现虽然依赖于缓存一致性协议来保证多核处理器间的可见性，但是它的完整实现还包括编译器层面的优化控制、内存屏障的插入、以及与Java内存模型的集成。这些机制共同工作，才能提供 volatile 关键字在 Java 中的完整语义。



`volatile` 特性：

- 保证单个变量的可见性
- 禁止编译器指令重排优化

局限性：不能保证



