在现代软件开发中，并发编程是提升程序性能和响应能力的重要手段。然而，随着多线程编程的引入，线程之间的数据共享和同步问题也变得异常复杂。如何在保证数据一致性的同时，避免线程竞争引发的错误，成为了每个开发者必须面对的挑战。为了解决这些问题，Java 提供了 Java 内存模型（Java Memory Model，JMM），它为 Java 中的并发编程奠定了理论基础。

JMM 通过定义线程与内存之间的交互方式，为开发者屏蔽了底层硬件和操作系统的差异，提供了一致性和可见性保障，使得跨平台的并发编程成为可能。在这篇文章中，我将介绍有关 JMM 的相关内容。

## 1. JMM 基础

在并发编程中，有两个核心问题需要解决：**线程间的通信**与**线程间的同步**。

线程间的通信通常有两种主要方式：一种是**基于共享内存**，线程通过**读写共享变量来交换数据**；另一种是**基于消息传递**，通过如**信号量**、**消息队列**等机制来进行线程间的通信。

Java 采用共享内存模型来实现线程间的通信，线程间的通信由 Java 内存模型（JMM）负责管理。JMM 决定了一个线程对共享变量的写入何时对其他线程可见。从抽象层面看，JMM 定义了线程与主内存之间的交互关系。通过控制主内存与各线程本地内存的交互，JMM 为 Java 程序提供了内存可见性保障。

JMM 定义了一套规范，屏蔽了不同硬件架构和操作系统在内存访问上的差异，抽象出 Java 程序中线程与共享内存的交互方式。通过 JVM 的实现，JMM 解决了线程间通信中的常见问题（如内存可见性、有序性和原子性），使得 Java 程序员只需遵循 JMM 的规范，无需关注底层细节，即可编写出跨平台且并发安全的程序。

以下为 Java 内存模型的抽象结构：

![Java线程与本地内存和共享内存的关系](/JMM.png)

Java 内存模型抽象出了线程和共享内存之间关系，在 Java 内存模型（JMM）中，所有线程共享的变量存储在共享内存（主内存）中，线程在操作这些变量时，会首先将它们从主内存拷贝到自己的本地内存（工作内存）中进行修改。修改后的值不会立即写回共享内存，除非通过同步机制（如 `volatile` 或 `synchronized`）将本地内存中的更新强制回写到主内存，从而保证其他线程能够看到最新的修改。JMM 通过这种模型解决了线程之间的内存可见性和一致性问题。

**共享内存（主内存）**：共享内存（也称为主内存）是 JMM 中线程之间**共享变量**的存储区域。Java 中所有的**实例变量**、**类变量**都存储在主内存中。所有线程都可以读取和写入共享内存中的变量，但由于线程有自己的本地内存，线程对共享变量的修改不一定会立即对其他线程可见。在硬件层面，共享内存通常对应于计算机的物理内存（RAM）。

**本地内存（工作内存）**：本地内存是被**抽象**出来的概念，用来描述每个线程独有的内存区域，实际上不是真实存在的，是对线程在硬件层面缓存机制的抽象，包括寄存器、CPU缓存、写缓存冲区等。这个抽象概念的目的是帮助理解线程对共享变量的操作在多线程环境下**如何影响内存的可见性和一致性**。

## 2. Happens-Before

 JMM 是一个非常复杂的规范，它描述了 Java 程序在多处理器系统中如何工作。但对于大多数程序员来说，他们不需要了解所有底层的硬件细节，比如缓存一致性协议、写缓冲区、内存屏障等。JMM 的大部分复杂性通过 Happens-Before 规则对程序员进行封装和屏蔽，因此这种观点实际上反映了 JMM 为程序员提供了一个“用户友好”的抽象层，这就是 Happens-Before。  

**Happens-Before** 是 JMM 中用来帮助程序员理解和控制多线程环境下操作顺序和可见性的一组规则。它以一种更高层次、更抽象的方式，将 JMM 的复杂底层机制以程序员能够理解的形式“呈现”出来。因此，**Happens-Before 确实可以被看作 JMM 呈现给程序员的视图**，因为它为程序员提供了一种推理并发行为的工具，而不必直接深入到复杂的内存模型或硬件优化的层面。  

### 2.1 基础概念

💡**Happens-Before 含义：对于一个共享变量来说，前面一个操作的结果对后面的操作是可见的。**

**Happens-Before 规则** 定义了两个操作之间的**顺序性**和**内存可见性**关系：

- **顺序性**：如果一个操作 `A` **Happens-Before** 操作 `B`，则 `A` 必须先执行，`B` 必须后执行，不能发生重排序。
- **内存可见性**：如果 `A` **Happens-Before**`B`，则 `A` 的结果（比如对共享变量的修改）对于 `B` 是可见的，也就是说，`B` 可以看到 `A` 对共享变量的修改。

### 2.2 Happens-Before 规则

- **程序顺序规则**：在同一个线程中，程序按照**代码顺序**执行。也就是说，前面操作一定 Happens-Before 后面所有的任意操作。
- **volatile 变量规则**：**对 volatile 变量的写操作** Happens-Before 后续**对该变量的读操作**。
- **传递性规则**：如果 A Happens-Before B，且 B Happens-Before C，那么 A Happens-Before C 。
- **锁规则**：锁的释放（unlock）Happens-Before 锁的获取（lock）。即如果线程 A 释放了一个锁，线程 B 随后获取了该锁，那么 A 在释放锁之前的所有操作对 B 是可见的。
- **线程启动规则**：`Thread.start()`Happens-Before 线程内部的任何操作。即在线程 A 中调用`Thread.start`来启动线程 B 后，A 中的`start()`操作 Happens-Before 线程 B 内部的任何操作。
- **线程终止规则**：线程的所有操作 Happens-Before `Thread.join()`。即如果线程 A 调用了`Thread.join()`来等待线程 B 结束，那么线程 B 中的所有操作 Happens-Before 线程 A 通过 `join()`返回之后的操作。
- **对象构造规则**：对象构造函数对`final`字段的写操作 Happens-Before 该对象的引用被发布。即如果一个对象的`final`字段在构造函数中赋值，那么该赋值操作对其他线程可见。

## 3. JMM 与 JVM 和硬件的关系

JMM 作为一个抽象模型，定义了 Java 程序中线程与共享内存交互的规则，确保内存操作的**一致性**和**可见性**。在实际运行时，JMM 的实现依赖于底层硬件（如 CPU、缓存、内存）与 JVM 的紧密协作。硬件提供基本的并发原语（如内存屏障、缓存一致性机制等），而 JVM 负责将这些抽象的 JMM 规则映射为具体的硬件指令，以确保多线程环境下的内存操作符合 JMM 的要求，从而实现线程安全的并发操作。

