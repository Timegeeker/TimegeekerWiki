**内部类**是一种定义在另一个类内部的类。Java 内部类提供了一种将逻辑相关的类紧密绑定在一起的方式，同时避免了命名空间污染。Java 支持以下几种类型的内部类：

1. **静态内部类（Static Nested Class）**
2. **成员内部类（Non-static Inner Class）**
3. **局部内部类（Local Inner Class）**
4. **匿名内部类（Anonymous Inner Class）**

每种类型的内部类在语法、功能和底层实现上都有其独特之处。

## 静态内部类

静态内部类使用 `static` 修饰符，实际上它是一种 **嵌套类** ，并不依赖于外部类的实例。可以直接通过外部类名来访问该类，就像访问外部类的静态成员一样。

```java
class Outer{
    static class StaticNested{
        void display(){
            System.out.println("我是静态内部类");
        }
    }
}
```

静态内部类没有外部引用的，且只能访问外部类的静态成员。它更像是一个与外部类相关但独立的类。静态内部类编译后会生成类似 `Outer$StaticNested.class` 的字节码文件，在编译后被看作是一个独立的类，只不过带有外部类的作用域（通过类名前缀关联）。同时，静态内部类的加载是懒加载，即只会在第一次使用的时候才进行加载，常常用来实现线程安全的单例模式。

静态内部类常用于类似外部类的逻辑分组，但又不需要访问外部类实例的场景。比如在 Java 的标准库中，`Map.Entry` 就是一个场景的静态内部类的例子。

## 成员内部类

成员内部类是没有 `static` 修饰的类，定义在外部类中。它可以直接访问外部类的实例成员。

```java
class Outer{
    class Inner{
        void display(){
            System.out.println("我是成员内部类");
        }
    }
}
```

成员内部类持有对外部实例的引用，可以访问外部类的所有成员（包括私有成员），但需要通过外部类的实例来创建成员内部类的实例：

```java
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
```

成员内部类编译后，内部类会生成类似 `Outer$Inner.class` 的字节码文件，每个成员内部类都会隐式地包含一个对外部实例的引用（这在底层是通过编译器隐式生成的 `this$0` 引用完成的）。内部类的实例化时会传递外部类的引用，这意味着即使在不同的上下文，成员内部类始终保持对外部类的访问权。

成员内部类主要在需要紧密绑定外部类的逻辑时使用。例如，当内部类的操作与外部类密切相关时。典型的应用场景包括数据结构中的迭代器（如 `List` 的 `Iterator` 实现）等。

## 局部内部类

局部内部类定义在方法或代码块内部，作用域仅限于该方法或代码块。

```java
class Outer{
    void method(){
        class LocalInner{
            void display(){
                System.out.println("我是局部内部类");
            }
        }
        LocalInner inner = new LocalInner();
        inner.display();
    }
}
```

局部内部类只能在其定义的方法或代码块中使用。它可以访问外部类的成员，以及所在方法的局部变量（但要求**局部变量必须是 final 修饰的变量**）。

局部内部类生成的字节码名称是类似 `Outer$1LocalInner.class` ，这里的 `1` 表示这是外部类的第一个局部内部类。编译器会通过捕获的方式，让局部内部类能够访问所在方法的局部变量，这是通过内部机制生成类似“合成”变量的方式完成的。

局部内部类适用于封装仅限于某个方法中的临时逻辑。因为它的作用范围非常有限，所以再结构化复杂代码时十分有用。

## 匿名内部类

匿名内部类是一种没有名称的内部类，通常用于实现接口或基础类时只需要定义一次性逻辑的情况。

```java
class Outer{
    void method(){
        Runnable r = new Runnable(){
            @Override
            public void run(){
                System.out.println("我是匿名内部类");
            }
        }
        new Thread(r).start();
    }
}
```

匿名内部类不能有构造函数，因为它没有名称，但可以使用初始化块来完成初始化工作。匿名内部类直接继承一个类或者实现一个接口，并且只能使用一次。

匿名内部类的字节码文件名称会像 `Outer$1.class` 这样，通过序号标识它是外部类的第一个匿名类。与局部内部类相似，匿名内部类也会捕获其外部环境中的局部变量或外部类的成员。

匿名内部类最常用于一次性逻辑的实现，例如在事件处理、回调或简单的多线程编程中，它简化了代码，同时使得实现局部逻辑变得更易读。

